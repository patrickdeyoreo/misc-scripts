#!/usr/bin/env bash
#
## create and display simple notes
###


###
## errmsg - print an error message
##
## usage: errmsg [name ...] error
##
## @name: program(s), function(s), or value(s) to prepend
## @error: the error message to print
##
## Return: the exit status of the command before this function
###
errmsg()
{
  trap "$(
  printf "%s\nreturn $?" "$(
    : "$(trap -p RETURN)"
    printf '%s' "${_:-trap RETURN}"
  )"
  )" RETURN
  if (( $# > 0 )); then
    if (( $# > 1 )); then
      printf '%s: ' "${@:1:($# - 1)}"
    fi
    printf '%s\n' "${!#}"
  fi 1>&2
}


###
## assign_by_ref - assign a value to a variable by reference
##
## usage: assign_by_ref name [value]
##
## @name: the name of a variable
## @value: the value to assign
##
## Return: 1 if name is an invalid identifier or an array with a bad subscript,
## otherwise 0
###
assign_by_ref()
{
  [[ $1 =~ ^([[:alpha:]_][[:alnum:]_]*)(\[(.*)])?$ ]] || 
    errmsg "${0##*/}" "$1" 'not a valid identifier'   ||
    return
  if [[ ${BASH_REMATCH[2]} = ?(\[*([[:blank:]])+([[:digit:]])*([[:blank:]])]) ]]
  then
    eval "$1"'=$2'
  elif [[ ${!BASH_REMATCH[1]@a} = *A* ]]; then
    eval "${BASH_REMATCH[1]}[${BASH_REMATCH[3]@Q}]"'=$2'
  else
    errmsg "${0#*/}" "${BASH_REMATCH[1]}[${BASH_REMATCH[3]@Q}]" \
      'bad array subscript'
  fi
}


###
## get_opts_by_ref - assign options to an associative array by reference
##
## usage: get_opts_by_ref name [arg ...]
##
## @name: the name of an associative array to store options & arguments
## @arg: argument(s) to parse for options
##
## Return: 2 if an invalid option is found or an option is missing an argument,
## 1 if name is an invalid identifier or an array with a bad subscript,
## otherwise 0
###
get_opts_by_ref()
{
  local optstring="${optstring}"
  local opt=''

  set -- "${@:2}" "$1"

  while getopts ":${optstring}" opt; do
    case "${opt}" in
      : ) errmsg "${0##*/}" "${OPTARG}" 'option requires an argument'
          return 2
          ;;
      \?) errmsg "${0##*/}" "${OPTARG}" 'invalid option'
          return 2
          ;;
      * ) assign_by_ref "${!#}[${opt}]" "${OPTARG}"
          ;;
    esac
  done
}


###
## list - list notes
##
## usage: list
##
## Return: 0 unless note directory cannot be accessed
###
note::list()
{
  local size="${#NOTES[@]}"

  for _ in "${!NOTES[@]}"; do
    printf '(%0'"${#size}"'d) %s\n' "$_" "$(
    date -d "${NOTES[_]##*/}" +"${NOTE_TIME_FMT}"
    )"
  done
}


###
## new - create a note
##
## usage: new
##
## Return: 0 unless note cannot be written
###
note::new()
{
  local -
  set -o noclobber

  local tempfile=''

  trap -- 'echo; return 130' SIGINT
  trap -- 'trap SIGINT; '"$(
  : "$(trap -p RETURN)"
  printf '%s' "${_:-trap RETURN}"
  )"$'\nrm -rf "${tempfile}" || true' RETURN
  trap 'rm -rf "${tempfile}" || true' EXIT

  tempfile=$(mktemp --tmpdir "${0##*/}-XXXXXX")

  cat 1>|"${tempfile}"

  until cat "${tempfile}" 1>"${NOTE_HOME}/$(printf "%(${NOTE_NAME_FMT})T")"; do
    [[ -d ${NOTE_HOME} ]] ||
      errmsg 2>&1 1>&3 "${0##*/}" "${NOTE_HOME}" 'directory has been removed'
    [[ -r ${NOTE_HOME} && -w ${NOTE_HOME} && -x ${NOTE_HOME} ]] ||
      errmsg 2>&1 1>&3 "${0##*/}" "${NOTE_HOME}" 'cannot access directory'
  done 3>&1 1>&2 2>/dev/null
}


###
## print - print notes
##
## usage: print
##
## Return: 0 unless notes cannot be accessed
###
note::print()
{
  local size="${#NOTES[@]}"

  for _ in "${!NOTES[@]}"; do
    if (( _ > 0 )); then
      printf '\n' "$_"
    fi
    printf '(%0'"${#size}"'d) %s\n%s\n' "$_" "$(
    date -d "${NOTES[_]##*/}" +"${NOTE_TIME_FMT}"
    )" "$(< "${NOTES[_]}")"
  done
}


###
## remove - remove a note
##
## usage: remove
###
note::remove()
{
  printf 'sorry, this is not implemented yet\n'
}


###
## search - search for a note
##
## usage: search
###
note::search()
{
  printf 'sorry, this is not implemented yet\n'
}


###
## usage - print a short usage synopsis
##
## usage: usage
###
note::usage()
{
  printf 'usage: %s [(l)ist|(n)ew|(p)rint|(r)emove|(s)earch]\n' "${0##*/}"
}


###
## main - start it up
##
## usage: main [option ...] [command ...]
##
## @option: option(s) to process
## @command: command(s) to execute
##
## Return: 0 upon successful execution; non-zero otherwise
###
note::main()
{
  local -
  set -o errtrace

  trap -- "$(
  : "$(trap -p ERR)"
  printf '%s\n' "${_:-trap ERR}"
  : "$(trap -p RETURN)"
  printf '%s\n' "${_:-trap RETURN}"
  )" RETURN
  trap -- 'return "$?"' ERR

  local NOTE_HOME="${NOTE_HOME:-${XDG_DATA_HOME:-${HOME}/.local/share}/note}"

  local NOTE_TIME_FMT="${NOTE_TIME_FMT:-%A %_d %B %Y %_I:%M %p}"

  local NOTE_NAME_FMT='%FT%T'
  
  local NOTES=( "${NOTE_HOME}"/* )

  [[ -e ${NOTES[0]} ]] || NOTES=( )

  if [[ ! -d ${NOTE_HOME} ]]; then
    mkdir -m 0700 -p "${NOTE_HOME}" ||
      errmsg "${0##*/}" "${NOTE_HOME}" "cannot create directory"
  fi

  case ${1^} in
    H*)
      [[ HELP != "${1^^}"* ]] ||
        { note::usage "$@"  && return ; }
      ;;&
    L*)
      [[ LIST != "${1^^}"* ]] ||
        { note::list "$@"   && return ; }
      ;;&
    N*)
      [[ NEW != "${1^^}"* ]] ||
        { note::new "$@"    && return ; }
      ;;&
    P*)
      [[ PRINT != "${1^^}"* ]] ||
        { note::print "$@"  && return ; }
      ;;&
    R*)
      [[ REMOVE != "${1^^}"* ]] ||
        { note::remove "$@" && return ; }
      ;;&
    S*)
      [[ SEARCH != "${1^^}"* ]] ||
        { note::search "$@" && return ; }
      ;;&
    * )
      if (( $# )); then
        errmsg "${0##*/}" "$1" 'unrecognized command'
      fi
      note::usage 1>&2
      return 2
      ;;
  esac

}


note::main "$@"
