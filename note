#!/usr/bin/env bash
#
## create and display simple notes
###


###
## errmsg - print an error message
##
## usage: errmsg [name ...] error
##
## @name: program(s), function(s), or value(s) to prepend
## @error: the error message to print
##
## Return: the exit status of the command before this function
###
errmsg()
{
  trap "$(
  printf "%s\nreturn $?" "$(
    : "$(trap -p RETURN)"
    printf '%s' "${_:-trap RETURN}"
  )"
  )" RETURN
  if (( $# > 0 )); then
    if (( $# > 1 )); then
      printf '%s: ' "${@:1:($# - 1)}"
    fi
    printf '%s\n' "${!#}"
  fi 1>&2
}


###
## assign_by_ref - assign a value to a variable by reference
##
## usage: assign_by_ref name [value]
##
## @name: the name of a variable
## @value: the value to assign
##
## Return: 0 unless name is an invalid identifier
###
assign_by_ref()
{
  [[ $1 =~ ([[:alpha:]_][[:alnum:]_]*)(\[([[:print:]]+)\])? ]] ||
    return
  if [[ ${BASH_REMATCH[2]} == ?(\[*( )+([[:digit:]])*( )]) ]]; then
    eval "$1"'="$2"'
  elif [[ ${!BASH_REMATCH[1]@a} == *A* ]]; then
    eval "${BASH_REMATCH[1]}['${BASH_REMATCH[3]//\'/\'\\\'\'}']"'=$2'
  fi
}


###
## get_argc_by_ref - assign argument count to a variable by reference
##
## usage: get_argc_by_ref name [arg ...]
##
## @name: the name of a variable
## @arg: arg(s) to count
##
## Return: 0 unless name is an invalid identifier
###
get_argc_by_ref()
{
  assign_by_ref "$1" "$(( $# - 1 ))"
}


###
## get_opts_by_ref - assign options to an associative array by reference
##
## usage: get_opts_by_ref name [arg ...]
##
## @name: the name of an associative array to store options with arguments
## @arg: argument(s) to parse for options
##
## Return: 2 upon encountering an invalid option or missing argument,
## otherwise 0 unless name is an invalid identifier
###
get_opts_by_ref()
{
  local OPTIND=1
  local optstring=${optstring:-f:h}
  local opt=''

  set -- "${@:2}" "$1"

  while getopts ":${optstring#:}" opt; do
    case "${opt}" in
      : ) errmsg "${0##*/}" "${OPTARG}" 'option requires an argument'
          return 2
          ;;
      \?) errmsg "${0##*/}" "${OPTARG}" 'invalid option'
          return 2
          ;;
      * ) assign_by_ref "${!#}[${opt}]" "${OPTARG}"
          ;;
    esac
  done
}


###
## list - list notes
##
## usage: list
##
## Return: Always 0
###
note::list()
{
  for _ in "${NOTES[@]##*/}"; do
    printf '>> %s\n' "$(date --date="$_" +"${NOTE_TIME_FMT}")"
  done
}


###
## new - create a note
##
## usage: new
##
## Return: 0 unless note cannot be written
###
note::new()
{
  local -
  set -o noclobber

  local tempfile=''

  trap -- 'echo; return 130' SIGINT
  trap -- 'trap SIGINT; '"$(
  : "$(trap -p RETURN)"
  printf '%s' "${_:-trap RETURN}"
  )"$'\nrm -rf "${tempfile}" || true' RETURN
  trap 'rm -rf "${tempfile}" || true' EXIT

  tempfile=$(mktemp --tmpdir "${0##*/}-XXXXXX")

  cat >| "${tempfile}"

  until cat "${tempfile}" 1> "${NOTE_HOME}/$(printf "%(${NOTE_NAME_FMT})T")"; do
    [[ -d ${NOTE_HOME} ]] ||
      errmsg 2>&1 "${0##*/}" "${NOTE_HOME}" 'directory has been removed'
    [[ -r ${NOTE_HOME} && -w ${NOTE_HOME} && -x ${NOTE_HOME} ]] ||
      errmsg 2>&1 "${0##*/}" "${NOTE_HOME}" 'cannot access directory'
  done 1>&2 2>/dev/null
}


###
## print - print notes
##
## usage: print
##
## Return: 0 unless notes cannot be accessed
###
note::print()
{
  for _ in "${NOTES[@]}"; do
    printf '>> %s\n%s\n' "$(date -d "${_##*/}" +"${NOTE_TIME_FMT}")" "$(< "$_")"
  done
}


###
## remove - remove a note
##
## usage: remove
###
note::remove()
{
  echo 'sorry, this is not implemented yet\n'
}


###
## search - search for a note
##
## usage: search
###
note::search()
{
  echo 'sorry, this is not implemented yet\n'
}


###
## usage - print a short usage synopsis
##
## usage: usage
###
note::usage()
{
  printf 'usage: %s [(l)ist|(n)ew|(p)rint|(r)emove|(s)earch]\n' "${0##*/}"
}


###
## main - start it up
##
## usage: main [option ...] [command ...]
##
## @option: option(s) to process
## @command: command(s) to execute
##
## Return: 0 upon successful execution; non-zero otherwise
###
main()
{
  local -
  set -o errtrace

  trap -- 'return "$?"' ERR
  trap -- 'trap - ERR RETURN' RETURN

  local NOTE_HOME="${NOTE_HOME:-${XDG_DATA_HOME:-${HOME}/.local/share}/note}"

  local NOTE_TIME_FMT="${NOTE_TIME_FMT:-%a %_d %b %Y %_I:%M %p}"

  local NOTE_NAME_FMT='%FT%T'
  
  local NOTES=( "${NOTE_HOME}"/* )

  [[ -e ${NOTES[0]} ]] || NOTES=( )

  if [[ ! -d ${NOTE_HOME} ]]; then
    mkdir -m 0700 -p "${NOTE_HOME}" ||
      errmsg "${0##*/}" "${NOTE_HOME}" "cannot create directory"
  fi

  case ${1^} in
    H*)
      [[ HELP == "${1^^}"* ]] &&
        note::usage
      ;;
    L*)
      [[ LIST == "${1^^}"* ]] &&
        note::list
      ;;
    N*)
      [[ NEW == "${1^^}"* ]] &&
        note::new
      ;;
    P*)
      [[ PRINT == "${1^^}"* ]] &&
        note::print
      ;;
    R*)
      [[ REMOVE == "${1^^}"* ]] &&
        note::remove
      ;;
    S*)
      [[ SEARCH == "${1^^}"* ]] &&
        note::search
      ;; 
    * )
      if (( $# )); then
        errmsg "${0##*/}" "$1" 'unrecognized command'
      fi
      note::usage 1>&2
      return 2
  esac

}


main "$@"
